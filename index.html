<!DOCTYPE html>
<html>
<head>
    <title>Spline Space</title>
    <meta name="description" content="Geometria Computazionale"/>
    <link rel="icon" type="image/x-icon" href="assets/sports_esports-24px.svg">

    <!-- Favicon/theme -->
    <link rel="shortcut icon" href="assets/sports_esports-24px.svg">

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,700" rel="stylesheet">
    <link href="styles.css" rel="stylesheet">

    <!-- Scripts -->
    <script type='text/javascript' src='scripts.js'></script>

    <!-- Google -->
    <meta name="google-site-verification" content="TOPBU-hLD3bnVo6E1puPdUFuR9G-6z3Mv18yJwf2iyY"/>

    <!-- MathJax -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>
<body>


<div class="container">

    <!-- TITOLO -->
    <div class="main">
        <img src="assets/logoUNIMI.png" class="logo" width="100" height="100">
        <h1>Spline Space</h1>
        <h2>Geometria Computazionale (A.A. 2020-2021)</h2>
        <div class="intro">
            <p>
                Spline Space &egrave; un videogioco 2D sviluppato con il motore grafico Unity. Il giocatore dovr&agrave;
                disegnare, mediante l'utilizzo di curve Spline, una traettoria che gli permetta di raccogliere tutti i
                checkpoint distribuiti sulla mappa entro un tempo limite.
            </p>
            <p>
                Il progetto &egrave; stato sviluppato per il corso di <a
                    href="http://www.mat.unimi.it/users/alzati/Geometria_Computazionale_98-99/">Geometria
                Computazionale</a> dell'Universit&agrave; degli Studi di Milano nell'anno accademico 2020/2021.
            </p>
        </div>
    </div>


    <!-- TEORIA -->
    <div class="changelog">
        <h2 class="title flash">Teoria</h2>
        <div class="exp">
            <p>
                Nel seguente progetto sono state implementate le curve Spline. Le curve permettono al giocatore di
                tracciare un percorso che consente alla navicella di raccogliere i checkpoint predisposti nel
                livello.
            </p>

            <h3>Curve di B&eacute;zier</h3>

            <p>
                Il nome deriva dal francese Pierre B&eacute;zier (1920-1999) che pubblic&ograve; per primo un articolo,
                mentre
                lavorava
                presso la casa automobilistica Renault come disegnatore e progettista.
            </p>

            <p>
                Le curve di B&eacute;zier vengono definite a partire da un numero finito di punti P0, P1, ..., Pn che
                formano il
                poligono di controllo. P0 e Pn costituiscono rispettivamente l'inizio e la fine della curva, gli altri
                punti
                invece
                non si trovano sulla curva ma contribuiscono a modellarne la forma. Il grado della curva &egrave; dato
                dal numero
                dei punti del poligono di controllo -1. Per calcolare una curva di B&eacute;zier si pu&ograve;
                utilizzare
                l'algoritmo di
                De Castelau,
                un algoritmo ricorsivo che per una curva di grado n prevede n-1 passi ricorsivi.
            </p>

            <p>
                <img src="assets/bezier2.png" width="auto" height="175">
            </p>


            <h4>Algoritmo di De Casteljau</h4>
            <p>
                &Egrave; un metodo che permette di costruire in modo semplice e algoritmico le curve nello spazio aventi
                rappresentazione parametrica di tipo polinomiale. Fissato un valore \(\text{\(t \in [0,1]\)}\), esso
                permette di calcolare il punto corrispondente sulla curva \(c(t)\) mediante interpolazioni lineari
                ripetute
                a partire dai punti di controllo.
            </p>
            <p>
                Dati \(n+1\) punti , la curva di grado \(n\) &egrave; data dalla seguente equazione di ricorrenza:
            </p>
            <p>
                \[P_{i}^{k}(t)=(1-t)P_{i}^{k-1}(t) + tP_{i+1}^{k-1}(t) \quad \text{\(t \in [0,1]\)} \quad , \quad con
                \quad
                k=1,2, \cdots , n \quad , \quad i=0,1, \cdots , n-k\]
            </p>


            <h4>Curve di B&eacute;zier lineari</h4>
            <p>
                Dati due punti \(P_{0}\) e \(P_{1}\) dello spazio affine, la curva di B&eacute;zier determinata da
                questi
                due punti e l'interpolazione lineare del segmento che li congiunge. Essa si muove di moto rettilineo
                uniforme e la legge oraria che descrive questo moto &egrave;:
            </p>
            <p>
                \[P(t)=(1-t)P_{0}+tP_{1} \quad \text{\(t \in [0,1]\)}\]
            </p>
            <p>
                Il segmento si riduce ad un unico punto se \(P_{0} = P_{1}\).
            </p>
            <p>
                <img src="assets/bl1.gif" width="auto" height="120">
            </p>


            <h4>Curve di B&eacute;zier quadratiche</h4>
            <p>
                Dati tre punti \(P_{0}\), \(P_{1}\) e \(P_{2}\) dello spazio affine, possiamo iterare l'interpolazione
                lineare ottenendo cos&igrave; una curva di B&eacute;zier quadratica definita dalla funzione:
            </p>
            <p>
                \[P(t)=(1-t)^2 P_{0} + 2t(1-t)P_{1} + t^2 P_{2} \quad \text{\(t \in [0,1]\)}\]
            </p>
            <p>
                Se i tre punti sono allineati, si ottiene ancora un segmento, anche se non pi&ugrave; percorso a velocit&agrave;
                costante.
            </p>
            <p>
                <img src="assets/bq2.gif" width="auto" height="120">
            </p>


            <h4>Curve di B&eacute;zier cubiche</h4>
            <p>
                In modo analogo si definiscono le curve di B&eacute;zier di terzo grado, iterando una volta in pi&ugrave;
                il
                procedimento
                di interpolazione lineare. Dati 4 punti \(P_{0}\), \(P_{1}\), \(P_{2}\) e \(P_{3}\) la legge oraria che
                descrive questo moto &egrave; data dalla funzione parametrica:
            </p>
            <p>
                \[P(t)=(1-t)^3 P_{0} + 3t(1-t)^2 P_{1} + 3t^2(1-t) P_{2} + t^3 P_{3} \quad \text{\(t \in [0,1]\)}\]
            </p>
            <p>
                <img src="assets/bc3.gif" width="auto" height="150">
            </p>


            <h3>Curve Spline</h3>
            <p>
                Si pu&ograve; pensare alle curve Spline come attaccature di curve di B&eacute;zier, queste curve possono
                essere
                lineari,
                quadratiche, cubiche o di grado maggiore. Nel nostro caso si &egrave; deciso di utilizzare curve di B&eacute;zier
                di grado
                3 che ci permettono di tracciare il primo
                e l'ultimo punto di ogni segmento e utilizzare gli altri due punti per modificarne la forma.
            </p>
            <p>
                Uno dei principali vantaggi di una curva Spline &egrave; il fatto che la modifica di un punto di
                controllo non si ripercuote su tutta la curva ma
                solo su
                una sua parte, questo permette quindi un controllo locale di quest'ultima. Nel gioco questo vantaggio
                &egrave;
                rilevante perch&egrave; permette al giocatore di cambiare una singola traettoria senza modificare le
                altre
                preconfigurate.
            </p>

            <p>
                Esistono diverse classi di incollamento tra due curve \(P\) e \(Q\) (curve con lo stesso grado \(k\)).
                Sappiamo che \(P\) &egrave; individuata in \(\{P_{0},\cdots,P_{k}\}\) e \(Q\) in
                \(\{Q_{0},\cdots,Q_{k}\}\).

                <img src="assets/retta.png" width="auto" height="150">
                \[P_{0} = a \quad , \quad P_{k} = b = Q_{0} \quad , \quad Q_{k} = c\]
            </p>


            <ul>
                <li class="job">
                    <div class="left">
                        \(C^{0}\) - questo tipo di incollamento si ottiene con \(P_{k}=Q_{0}\).<br>
                        Ovvero che l'ultimo punto della prima curva deve coincidere con il primo punto della seconda
                        curva,
                        condizione abbastanza ovvia per poter assicurare l'incollamento.
                        <div>
                            <div style="text-align:center;">Incollamento di classe \(C^{0}\)</div>
                            <img src="assets/c0.png" width="auto" height="150">
                        </div>
                    </div>
                </li>
                <li class="fun">
                    <div class="left">
                        \(C^{1}\) - questo tipo di incollamento si ottiene soddisfando \(C^{0}\) e \(P'(b)=Q'(b)\). Il
                        penultimo
                        punto della prima curva, l'ultimo punto della prima curva (che coincide con il primo della
                        seconda curva) ed il primo punto della seconda curva, devono essere sempre allineati. Inoltre
                        bisogna
                        far si
                        che \(P_{k}-P_{k-1}\) e \(Q_{0}-Q_{1}\) siano uguali. Per la realizzazione del progetto &egrave;
                        stata
                        implementato
                        questo tipo di curva.
                        <div>
                            <div style="text-align:center;">Incollamento di classe \(C^{1}\)</div>
                            <img src="assets/c1.png" width="auto" height="150">
                        </div>
                    </div>
                </li>
                <li class="event">
                    <div class="left">
                        \(C^{2}\) - questo di incollamento si ottiene soddisfando \(C^{1}\) e \(P''(b)=Q''(b)\).
                        Deve esistere
                        un
                        punto di intersezione \(D\) chiamato punto di De Boor che si ottiene dall'intersezione di
                        \(P_{k-2},
                        P_{k-1}\) con \(Q_{1}, Q_{2}\). Devono essere inoltre mantenuti i rapporti semplici tra
                        \(P_{k-1},
                        P_{k}(=Q_{0}), Q_{1}\), \(P_{k-2}, P_{k-1}, D\) e \(D, Q_{1}, Q_{2}\).
                        <div>
                            <div style="text-align:center;">Incollamento di classe \(C^{2}\)</div>
                            <img src="assets/c2.png" width="auto" height="270">
                        </div>
                    </div>
                </li>
            </ul>


            <h3>
                Implementazione
            </h3>
            <p>
                La curva implementata, come detto precedentemente, &egrave; una curva Spline che presenta incollature di
                classe
                \(C^{1}\) di curve di B&eacute;zier di grado 3. Le funzioni che si occupano di calcolare la curva di B&eacute;zier
                in
                funzione del parametro \(t\) sono:
            </p>
            <div style="margin: auto; width: 50%;">
                <code style="font-size: 120%;">
                    public Vector3 Lerp(Vector3 a, Vector3 b, float t)<br>
                    {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Vector3.Lerp(a, b, t);<br>
                    }<br><br>


                    public Vector3 QuadraticLerp(Vector3 a, Vector3 b, Vector3 c, float t)<br>
                    {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 ab = Vector3.Lerp(a, b, t);<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 bc = Vector3.Lerp(b, c, t);<br>
                    <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Vector3.Lerp(ab, bc, t);<br>
                    }<br><br>


                    public Vector3 CubicLerp(Vector3 a, Vector3 b, Vector3 c, Vector3 d, float t)<br>
                    {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 ac = QuadraticLerp(a, b, c, t);<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 bd = QuadraticLerp(b, c, d, t);<br>
                    <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Vector3.Lerp(ac, bd, t);<br>
                    }<br><br>
                </code>
            </div>
        </div>
    </div>

    <!-- MANUALE -->
    <div class="changelog">
        <h2 class="title flash">Manuale</h2>
        <div class="exp">
            <h3>Scopo del gioco</h3>
            <p>
                Lo scopo del gioco &egrave; quello di creare un percorso tramite l'utilizzo della curva Spline in modo
                tale
                da
                raccogliere tutti i checkpoint distribuiti nella mappa entro il tempo limite imposto dal livello.
            </p>

            <hr>

            <h3>Come giocare</h3>

            <h4>Posizionare un punto</h4>
            <p>
                Per l'inserimento di un punto di controllo nello schermo bisogna posizionare il mouse nel punto
                interessato e
                premere il
                tasto destro, in questo modo comparir&agrave; un pallino verde. Dopo aver inserito il secondo punto
                verranno generati anche i punti
                intermedi
                del poligono di controllo. Aggiungere un punto inoltre avvia il countdown.
            </p>

            <h4>Muovere un punto</h4>
            <p>
                Posizionare il cursore nel punto desiderato e tenerlo premuto col tasto
                sinistro
                del mouse per trascinarlo.
            </p>

            <h4>Modellare la curva</h4>
            <p>
                I pallini verdi rappresentano i punti iniziali e i punti finali delle curve di B&eacute;zier mentre i
                pallini bianchi rappresentano i punti intermedi del poligono di controllo. Il loro scopo &egrave;
                quello di
                permettere la modellazione della curva; muovere questi pallini permette di modellare il percorso
                attraverso il quale si supera il livello.
                <img src="assets/spline.png">
            </p>

            <h4>Far partire la navicella</h4>
            <p>
                Tramite il tasto RUN &egrave; possibile far partire la navicella che si muover&agrave; lungo il percorso
                precedentemente
                generato dal giocatore.
                <img src="assets/ship.png">
            </p>

            <h4>Collezionare i checkpoint</h4>
            <p>
                Raccogliere tutti i checkpoint &egrave; cruciale per ottenere la vittoria. Il giocatore deve
                fare
                in
                modo che il
                percorso generato con la curva Spline passi per ognuno di essi.
                <img src="assets/checkpoint.png">
            </p>


            <h4>Evitare gli ostacoli</h4>
            <p>
                I pianeti sono gli ostacoli da evitare, l'impatto con questi risulter&agrave; fatale per la navicella.
                <img src="assets/block.png">
            </p>

            <h4>Riflettere sul percorso ideale</h4>
            <p>
                Prima di posizionare il primo punto della curva Spline &egrave; opportuno riflettere sul percorso
                ideale, in quanto una volta posizionato parte il countdown.
            </p>

            <hr>

            <h3>Interfaccia utente</h3>

            <h4>Far partire la navicella</h4>
            <p>
                Tramite il tasto RUN &egrave; possibile far partire la navicella che si muover&agrave; lungo il percorso
                precedentemente
                generato dal giocatore.
                <img src="assets/run.png">
            </p>


            <h4>Reset partita</h4>
            <p>
                Tramite il tasto RESET &egrave; possibile ricominciare il livello, funzione utile nel momento in cui il
                giocatore
                si rende conto di aver sbagliato qualcosa. L'utilizzo del tasto RESET prevede il consumo di una vita.
                <img src="assets/reset.png">
            </p>


            <h4>Countdown</h4>
            <p>
                Il countdown &egrave; il tempo che parte quando si posiziona il primo punto della curva Spline. Il
                giocatore dovrà creare il percorso prima che il tempo scada, facendo attenzione a riservare qualche
                secondo per il percorso della navicella.
                <img src="assets/countdown.png">
            </p>


            <h4>Punteggio livello</h4>
            <p>
                Indica il punteggio attuale del giocatore, viene calcolato sulla base dei secondi rimanenti da un
                livello
                all'altro dopo il superamento di essi.
                <img src="assets/score.png">
            </p>


            <hr>

            <h3>Power Up e Malus</h3>
            <p>
                Sono gli oggetti che il giocatore pu&ograve; utilizzare a su&ograve; vantaggio o che dovr&agrave;
                evitare
                per eludere gli
                effetti negativi.
            </p>
            <h4>Crescita</h4>
            <p>
                La crescita aumenta le dimensioni della navicella e con essa anche le possibilit&agrave; di colpire gli
                ostacoli
                predisposti sullo schermo. La crescita fornir&agrave; inoltre 1 secondo in pi&ugrave; al tempo
                rimanente.
                <img src="assets/crescita.png">
            </p>

            <h4>Decrescita</h4>
            <p>
                La decrescita diminuisce le dimensioni della navicella e con essa anche le possibilit&agrave; di colpire
                gli
                ostacoli predisposti sullo schermo. La decrescita rimuover&agrave; inoltre 1 secondo dal tempo
                rimanente.
                <img src="assets/decrescita.png">
            </p>

            <h4>Velocit&agrave;</h4>
            <p>
                La velocit&agrave; permette alla navicella di muoversi pi&ugrave; velocemente.
                <img src="assets/velocita.png">
            </p>

            <h4>Rallentamento</h4>
            <p>
                Il rallentamento fa muovere la navicella pi&ugrave; lentamente.
                <img src="assets/rallentamento.png">
            </p>

            <h4>Pi&ugrave; secondi</h4>
            <p>
                Vengono aggiunti 2 secondi al tempo rimanente.
                <img src="assets/bonusSec.png">
            </p>

            <h4>Meno secondi</h4>
            <p>
                Vengono rimossi 2 secondi al tempo rimanente.
                <img src="assets/malusSec.png">
            </p>

        </div>
    </div>

    <!-- APPLET -->
    <div class="changelog">
        <h2 class="title flash">Applet</h2>
        <div class="exp">
            &Egrave; possibile giocare direttamente dal browser tramite WebGL, oppure scaricare la versione per Windows
            o MacOS.
            <ul>
                <li class="job">
                    <div class="left"><a href="https://www.google.it/">WebGL</a></div>
                </li>
                <li class="fun">
                    <div class="left"><a href="https://www.google.it/">Windows</a></div>
                </li>
                <li class="event">
                    <div class="left"><a href="https://www.google.it/">Mac OS</a></div>
                </li>
            </ul>
        </div>
    </div>

    <!-- END -->
    <div class="end">
        <h3>Contacts</h3>
        <p>
            Gerard Baholli - <a href="mailto:gerard.baholli@studenti.unimi.it">gerard.baholli@studenti.unimi.it</a>
        </p>
    </div>


</div>
</body>
</html>
