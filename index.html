<!DOCTYPE html>
<html>
<head>
    <title>Spline Space</title>
    <meta name="description" content="Geometria Computazionale"/>
    <link rel="icon" type="image/x-icon" href="assets/sports_esports-24px.svg">

    <!-- Favicon/theme -->
    <link rel="shortcut icon" href="assets/sports_esports-24px.svg">

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,700" rel="stylesheet">
    <link href="styles.css" rel="stylesheet">

    <!-- Scripts -->
    <script type='text/javascript' src='scripts.js'></script>

    <!-- Google -->
    <meta name="google-site-verification" content="TOPBU-hLD3bnVo6E1puPdUFuR9G-6z3Mv18yJwf2iyY"/>

    <!-- MathJax -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>
<body>


<div class="container">

    <!-- TITOLO -->
    <div class="main">
        <img src="assets/logoUNIMI.png" class="logo" width="100" height="100">
        <h1>Spline Space</h1>
        <h2>Geometria Computazionale (A.A. 2020-2021)</h2>
        <div class="intro">
            <p>
                Spline Space &egrave; un videogioco 2D sviluppato con il motore grafico Unity. Il giocatore dovr&agrave;
                disegnare, mediante l'utilizzo di curve Spline, una traettoria che gli permetta di raccogliere tutti i
                checkpoint distribuiti sulla mappa entro un tempo limite.
            </p>
            <p>
                Il progetto &egrave; stato sviluppato per il corso di <a
                    href="http://www.mat.unimi.it/users/alzati/Geometria_Computazionale_98-99/">Geometria
                Computazionale</a> dell'Universit&agrave; degli Studi di Milano nell'anno accademico 2020/2021.
            </p>
        </div>
    </div>


    <!-- TEORIA -->
    <div class="changelog">
        <h2 class="title flash">Teoria</h2>
        <div class="exp">
            <p>
                Nel seguente progetto sono state implementate le curve Spline per permettere al giocatore di tracciare
                il
                percorso che la navicella spaziale dovr&agrave; effettuare per raccogliere i checkpoint predisposti
                nella
                mappa. L'idea alla base delle curve Spline &egrave; quella di incollare pi&ugrave; curve di B&eacute;zier
                imponendo
                delle condizioni di regolarit&agrave; nei punti di saldatura.
            </p>

            <h3>Curve di B&eacute;zier</h3>

            <p>
                Il nome deriva dal francese Pierre B&eacute;zier (1920-1999) che pubblic&ograve; per primo un articolo,
                mentre
                lavorava
                presso la casa automobilistica Renault come disegnatore e progettista.
            </p>

            <p>
                Le curve di B&eacute;zier vengono definite a partire da un numero finito di punti P0, P1, ..., Pn che
                formano il
                poligono di controllo. P0 e Pn costituiscono rispettivamente l'inizio e la fine della curva, gli altri
                punti
                invece
                non si trovano sulla curva ma contribuiscono a modellarne la forma. Il grado della curva &egrave; dato
                dal numero
                dei punti del poligono di controllo -1. Per calcolare una curva di B&eacute;zier si pu&ograve;
                utilizzare
                l'algoritmo di
                De Castelau,
                un algoritmo ricorsivo che per una curva di grado n prevede n-1 passi ricorsivi.
            </p>

            <p>
                <img src="assets/bezier2.png" width="auto" height="175">
            </p>


            <h4>Algoritmo di De Casteljau</h4>
            <p>
                &Egrave; un metodo che permette di costruire in modo semplice e algoritmico le curve nello spazio aventi
                rappresentazione parametrica di tipo polinomiale. Fissato un valore \(\text{\(t \in [0,1]\)}\), esso
                permette di calcolare il punto corrispondente sulla curva \(c(t)\) mediante interpolazioni lineari
                ripetute
                a partire dai punti di controllo.
            </p>
            <p>
                Dati \(n+1\) punti , la curva di grado \(n\) &egrave; data dalla seguente equazione di ricorrenza:
            </p>
            <p>
                \[P_{i}^{k}(t)=(1-t)P_{i}^{k-1}(t) + tP_{i+1}^{k-1}(t) \quad \text{\(t \in [0,1]\)} \quad , \quad con
                \quad
                k=1,2, \cdots , n \quad , \quad i=0,1, \cdots , n-k\]
            </p>


            <h4>Curve di B&eacute;zier lineare</h4>
            <p>
                Dati due punti \(P_{0}\) e \(P_{1}\) dello spazio affine, la curva di B&eacute;zier determinata da
                questi
                due punti e l'interpolazione lineare del segmento che li congiunge. Essa si muove di moto rettilineo
                uniforme e la legge oraria che descrive questo moto &egrave;:
            </p>
            <p>
                \[P(t)=(1-t)P_{0}+tP_{1} \quad \text{\(t \in [0,1]\)}\]
            </p>
            <p>
                Il segmento si riduce ad un unico punto se \(P_{0} = P_{1}\).
            </p>
            <p>
                <img src="assets/bl1.gif" width="auto" height="120">
            </p>


            <h4>Curve di B&eacute;zier quadratica</h4>
            <p>
                Dati tre punti \(P_{0}\), \(P_{1}\) e \(P_{2}\) dello spazio affine, possiamo iterare l'interpolazione
                lineare ottenendo cos&igrave; una curva di B&eacute;zier quadratica definita dalla funzione:
            </p>
            <p>
                \[P(t)=(1-t)^2 P_{0} + 2t(1-t)P_{1} + t^2 P_{2} \quad \text{\(t \in [0,1]\)}\]
            </p>
            <p>
                Se i tre punti sono allineati, si ottiene ancora un segmento, anche se non pi&ugrave; percorso a velocit&agrave;
                costante.
            </p>
            <p>
                <img src="assets/bq2.gif" width="auto" height="120">
            </p>


            <h4>Curve di B&eacute;zier cubica</h4>
            <p>
                In modo analogo si definiscono le curve di B&eacute;zier di terzo grado, iterando una volta in pi&ugrave;
                il
                procedimento
                di interpolazione lineare. Dati 4 punti \(P_{0}\), \(P_{1}\), \(P_{2}\) e \(P_{3}\) la legge oraria che
                descrive questo moto &egrave; data dalla funzione parametrica:
            </p>
            <p>
                \[P(t)=(1-t)^3 P_{0} + 3t(1-t)^2 P_{1} + 3t^2(1-t) P_{2} + t^3 P_{3} \quad \text{\(t \in [0,1]\)}\]
            </p>
            <p>
                <img src="assets/bc3.gif" width="auto" height="150">
            </p>


            <h3>Curve Spline</h3>
            <p>
                Si pu&ograve; pensare alle curve Spline come attaccature di curve di B&eacute;zier, queste curve possono
                essere
                lineari,
                quadratiche, cubiche o di grado maggiore. Nel nostro caso si &egrave; deciso di utilizzare curve di B&eacute;zier
                di grado
                3 che ci permettono di tracciare il primo
                e l'ultimo punto di ogni segmento e utilizzare gli altri due punti per modificarne la forma.
            </p>
            <p>
                Uno dei principali vantaggi di una
                curva
                Spline &egrave; il fatto che la modifica di un punto di controllo non si ripercuote su tutta la curva ma
                solo su
                una sua parte, questo permette quindi un controllo locale di quest'ultima. Nel gioco questo vantaggio
                &egrave;
                rilevante perch&egrave; permette al giocatore di cambiare una singola traettoria senza modificare le
                altre
                preconfigurate.
            </p>

            <p>
                Esistono diverse classi di incollamento tra due curve \(P\) e \(Q\) (curve con lo stesso grado \(k\)).
                Sappiamo che \(P\) &egrave; individuata in \(\{P_{0},\cdots,P_{k}\}\) e \(Q\) in
                \(\{Q_{0},\cdots,Q_{k}\}\).

                <img src="assets/retta.png" width="auto" height="150">
                \[P_{0} = a \quad , \quad P_{k} = b = Q_{0} \quad , \quad Q_{k} = c\]
            </p>


            <p>
                \(C^{0}\) - questo tipo di incollamento di ottiene con \(P_{k}=Q_{0}\).<br>
                Ovvero che l'ultimo punto della prima curva deve coincidere con il primo punto della seconda curva,
                condizione abbastanza ovvia per poter assicurare l'incollamento.
            <div>
                <div style="text-align:center;">Incollamento di classe \(C^{0}\)</div>
                <img src="assets/c0.png" width="auto" height="150">
            </div>
            </p>


            <p>
                \(C^{1}\) - questo tipo di incollamento si ottiene soddisfando \(C^{0}\) e \(P'(b)=Q'(b)\). Il penultimo
                punto della prima curva, l'ultimo punto della prima curva (che coincide con il primo della
                seconda curva) ed il primo punto della seconda curva, devono essere sempre allineati. Inoltre bisogna
                far si
                che \(P_{k}-P_{k-1}\) e \(Q_{0}-Q_{1}\) siano uguali. Per la realizzazione del progetto &egrave; stata
                implementato
                questo tipo di curva.
            <div>
                <div style="text-align:center;">Incollamento di classe \(C^{1}\)</div>
                <img src="assets/c1.png" width="auto" height="150">
            </div>
            </p>


            <p>
                \(C^{2}\) - questo di incollamento si ottiene soddisfando \(C^{1}\) e \(P''(b)=Q''(b)\). Deve esistere
                un
                punto di intersezione \(D\) chiamato punto di De Boor che si ottiene dall'intersezione di \(P_{k-2},
                P_{k-1}\) con \(Q_{1}, Q_{2}\). Devono essere inoltre mantenuti i rapporti semplici tra \(P_{k-1},
                P_{k}(=Q_{0}), Q_{1}\), \(P_{k-2}, P_{k-1}, D\) e \(D, Q_{1}, Q_{2}\).
            <div>
                <div style="text-align:center;">Incollamento di classe \(C^{2}\)</div>
                <img src="assets/c2.png" width="auto" height="270">
            </div>
            </p>

            <h3>
                Implementazione
            </h3>
            <p>
                La curva implementata, come detto precedentemente, &egrave; una curva Spline che presenta incollature di
                classe
                \(C^{1}\) di curve di B&eacute;zier di grado 3. Le funzioni che si occupano di calcolare la curva di B&eacute;zier
                in
                funzione del parametro \(t\) sono:
            </p>
            <div style="margin: auto; width: 50%;">
                <code style="font-size: 120%;">
                    public Vector3 Lerp(Vector3 a, Vector3 b, float t)<br>
                    {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Vector3.Lerp(a, b, t);<br>
                    }<br><br>


                    public Vector3 QuadraticLerp(Vector3 a, Vector3 b, Vector3 c, float t)<br>
                    {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 ab = Vector3.Lerp(a, b, t);<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 bc = Vector3.Lerp(b, c, t);<br>
                    <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Vector3.Lerp(ab, bc, t);<br>
                    }<br><br>


                    public Vector3 CubicLerp(Vector3 a, Vector3 b, Vector3 c, Vector3 d, float t)<br>
                    {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 ac = QuadraticLerp(a, b, c, t);<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 bd = QuadraticLerp(b, c, d, t);<br>
                    <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Vector3.Lerp(ac, bd, t);<br>
                    }<br><br>
                </code>
            </div>
        </div>
    </div>

    <!-- MANUALE -->
    <div class="changelog">
        <h2 class="title flash">Manuale</h2>
        <div class="exp">
            Lo scopo del gioco ...
        </div>
    </div>

    <!-- APPLET -->
    <div class="changelog">
        <h2 class="title flash">Applet</h2>
        <div class="exp">
            &Egrave; possibile giocare direttamente dal browser tramite WebGL, oppure scaricare la versione per Windows
            o MacOS.
            <ul>
                <li class="job">
                    <div class="left"><a href="applet.html">WebGL</a></div>
                </li>
                <li class="fun">
                    <div class="left"><a
                            href="https://github.com/gerardbaholli/level-design-document/raw/master/main.pdf">Windows</a>
                    </div>
                </li>
                <li class="event">
                    <div class="left"><a
                            href="https://github.com/gerardbaholli/level-design-document/raw/master/main.pdf">Mac OS</a>
                    </div>
                </li>
            </ul>
        </div>
    </div>

    <!-- END -->
    <div class="end">
        <h3>Contacts</h3>
        <p>
            Gerard Baholli - <a href="mailto:gerard.baholli@studenti.unimi.it">gerard.baholli@studenti.unimi.it</a>
        </p>
    </div>


</div>
</body>
</html>
