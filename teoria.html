<!DOCTYPE html>
<html>
<head>
    <title>Spline Space</title>
    <meta content="Geometria Computazionale" name="description"/>
    <link href="assets/sports_esports-24px.svg" rel="icon" type="image/x-icon">

    <!-- Favicon/theme -->
    <link href="assets/sports_esports-24px.svg" rel="shortcut icon">

    <meta content="width=device-width, initial-scale=1, maximum-scale=1" name="viewport">

    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,700" rel="stylesheet">
    <link href="styles.css" rel="stylesheet">

    <!-- Scripts -->
    <script src='scripts.js' type='text/javascript'></script>

    <!-- Google -->
    <meta content="TOPBU-hLD3bnVo6E1puPdUFuR9G-6z3Mv18yJwf2iyY" name="google-site-verification"/>

    <!-- MathJax -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script async id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>
<body>


<div class="container">

    <!-- TITLE + LINKS -->
    <div class="main">
        <img class="logo" height="100" src="assets/logoUNIMI.png" width="100">
        <h1>Spline Space</h1>
        <h2>Geometria Computazionale (A.A. 2020-2021)</h2>
        <!-- LINKS -->
        <div class="links">
            <a href="index.html">Home</a>
            <a href="teoria.html">Teoria</a>
            <a href="manuale.html">Manuale</a>
            <a href="applet.html">Applet</a>
        </div>
    </div>


    <h1>Teoria</h1>
    <p>
        Nel seguente progetto sono state implementate le curve Spline. Le curve permettono al giocatore di
        tracciare un percorso che consente alla navicella di raccogliere i checkpoint predisposti nel
        livello.
    </p>

    <h3>Curve di B&eacute;zier</h3>

    <p>
        Il nome deriva dal francese Pierre B&eacute;zier (1920-1999) che pubblic&ograve; per primo un articolo,
        mentre
        lavorava
        presso la casa automobilistica Renault come disegnatore e progettista.
    </p>

    <p>
        Le curve di B&eacute;zier vengono definite a partire da un numero finito di punti P0, P1, ..., Pn che
        formano il
        poligono di controllo. P0 e Pn costituiscono rispettivamente l'inizio e la fine della curva, gli altri
        punti
        invece
        non si trovano sulla curva ma contribuiscono a modellarne la forma. Il grado della curva &egrave; dato
        dal numero
        dei punti del poligono di controllo -1. Per calcolare una curva di B&eacute;zier si pu&ograve;
        utilizzare
        l'algoritmo di
        De Castelau,
        un algoritmo ricorsivo che per una curva di grado n prevede n-1 passi ricorsivi.
    </p>

    <p>
        <img height="175" src="assets/bezier2.png" width="auto">
    </p>


    <h4>Algoritmo di De Casteljau</h4>
    <p>
        &Egrave; un metodo che permette di costruire in modo semplice e algoritmico le curve nello spazio aventi
        rappresentazione parametrica di tipo polinomiale. Fissato un valore \(\text{\(t \in [0,1]\)}\), esso
        permette di calcolare il punto corrispondente sulla curva \(c(t)\) mediante interpolazioni lineari
        ripetute
        a partire dai punti di controllo.
    </p>
    <p>
        Dati \(n+1\) punti , la curva di grado \(n\) &egrave; data dalla seguente equazione di ricorrenza:
    </p>
    <p>
        \[P_{i}^{k}(t)=(1-t)P_{i}^{k-1}(t) + tP_{i+1}^{k-1}(t) \quad \text{\(t \in [0,1]\)} \quad , \quad con
        \quad
        k=1,2, \cdots , n \quad , \quad i=0,1, \cdots , n-k\]
    </p>


    <h4>Curve di B&eacute;zier lineari</h4>
    <p>
        Dati due punti \(P_{0}\) e \(P_{1}\) dello spazio affine, la curva di B&eacute;zier determinata da
        questi
        due punti e l'interpolazione lineare del segmento che li congiunge. Essa si muove di moto rettilineo
        uniforme e la legge oraria che descrive questo moto &egrave;:
    </p>
    <p>
        \[P(t)=(1-t)P_{0}+tP_{1} \quad \text{\(t \in [0,1]\)}\]
    </p>
    <p>
        Il segmento si riduce ad un unico punto se \(P_{0} = P_{1}\).
    </p>
    <p>
        <img height="120" src="assets/bl1.gif" width="auto">
    </p>


    <h4>Curve di B&eacute;zier quadratiche</h4>
    <p>
        Dati tre punti \(P_{0}\), \(P_{1}\) e \(P_{2}\) dello spazio affine, possiamo iterare l'interpolazione
        lineare ottenendo cos&igrave; una curva di B&eacute;zier quadratica definita dalla funzione:
    </p>
    <p>
        \[P(t)=(1-t)^2 P_{0} + 2t(1-t)P_{1} + t^2 P_{2} \quad \text{\(t \in [0,1]\)}\]
    </p>
    <p>
        Se i tre punti sono allineati, si ottiene ancora un segmento, anche se non pi&ugrave; percorso a velocit&agrave;
        costante.
    </p>
    <p>
        <img height="120" src="assets/bq2.gif" width="auto">
    </p>


    <h4>Curve di B&eacute;zier cubiche</h4>
    <p>
        In modo analogo si definiscono le curve di B&eacute;zier di terzo grado, iterando una volta in pi&ugrave;
        il
        procedimento
        di interpolazione lineare. Dati 4 punti \(P_{0}\), \(P_{1}\), \(P_{2}\) e \(P_{3}\) la legge oraria che
        descrive questo moto &egrave; data dalla funzione parametrica:
    </p>
    <p>
        \[P(t)=(1-t)^3 P_{0} + 3t(1-t)^2 P_{1} + 3t^2(1-t) P_{2} + t^3 P_{3} \quad \text{\(t \in [0,1]\)}\]
    </p>
    <p>
        <img height="150" src="assets/bc3.gif" width="auto">
    </p>


    <h3>Curve Spline</h3>
    <p>
        Si pu&ograve; pensare alle curve Spline come attaccature di curve di B&eacute;zier, queste curve possono
        essere
        lineari,
        quadratiche, cubiche o di grado maggiore. Nel nostro caso si &egrave; deciso di utilizzare curve di B&eacute;zier
        di grado
        3 che ci permettono di tracciare il primo
        e l'ultimo punto di ogni segmento e utilizzare gli altri due punti per modificarne la forma.
    </p>
    <p>
        Uno dei principali vantaggi di una curva Spline &egrave; il fatto che la modifica di un punto di
        controllo non si ripercuote su tutta la curva ma
        solo su
        una sua parte, questo permette quindi un controllo locale di quest'ultima. Nel gioco questo vantaggio
        &egrave;
        rilevante perch&egrave; permette al giocatore di cambiare una singola traettoria senza modificare le
        altre
        preconfigurate.
    </p>

    <p>
        Esistono diverse classi di incollamento tra due curve \(P\) e \(Q\) (curve con lo stesso grado \(k\)).
        Sappiamo che \(P\) &egrave; individuata in \(\{P_{0},\cdots,P_{k}\}\) e \(Q\) in
        \(\{Q_{0},\cdots,Q_{k}\}\).

        <img src="assets/retta.png" height="150" width="auto">
        \[P_{0} = a \quad , \quad P_{k} = b = Q_{0} \quad , \quad Q_{k} = c\]
    </p>


    <ul>
        <li class="job">
            <div class="left">
                \(C^{0}\) - questo tipo di incollamento si ottiene con \(P_{k}=Q_{0}\).<br>
                Ovvero che l'ultimo punto della prima curva deve coincidere con il primo punto della seconda
                curva,
                condizione abbastanza ovvia per poter assicurare l'incollamento.
                <div>
                    <br>
                    <div style="text-align:center;">Incollamento di classe \(C^{0}\)</div>
                    <img height="150" src="assets/c0.png" width="auto">
                </div>
            </div>
        </li>
        <li class="fun">
            <div class="left">
                \(C^{1}\) - questo tipo di incollamento si ottiene soddisfando \(C^{0}\) e \(P'(b)=Q'(b)\). Il
                penultimo
                punto della prima curva, l'ultimo punto della prima curva (che coincide con il primo della
                seconda curva) ed il primo punto della seconda curva, devono essere sempre allineati. Inoltre
                bisogna far si che il rapporto semplice dato dai 3 punti allineati deve coincidere con il
                rapporto semplice dato dai 3 numeri reali \(a,b,c\) che costituiscono i nodi della Spline. Per
                la realizzazione del progetto &egrave;
                stata
                implementata una curva Spline uniforme con incollamento di tipo \(C^{1}\).
                <br>
                <div>
                    <br>
                    <div style="text-align:center;">Incollamento di classe \(C^{1}\)</div>
                    <img height="150" src="assets/c1.png" width="auto">
                </div>
            </div>
        </li>
        <li class="event">
            <div class="left">
                \(C^{2}\) - questo di incollamento si ottiene soddisfando \(C^{1}\) e \(P''(b)=Q''(b)\).
                Deve esistere
                un
                punto di intersezione \(D\) chiamato punto di De Boor che si ottiene dall'intersezione di
                \(P_{k-2},
                P_{k-1}\) con \(Q_{1}, Q_{2}\). Devono essere inoltre mantenuti i rapporti semplici tra
                \(P_{k-1},
                P_{k}(=Q_{0}), Q_{1}\), \(P_{k-2}, P_{k-1}, D\) e \(D, Q_{1}, Q_{2}\) che devono coincidere con
                il rapporto semplice dei 3 numeri reali \(a,b,c\).
                <br>
                <div>
                    <br>
                    <div style="text-align:center;">Incollamento di classe \(C^{2}\)</div>
                    <img height="270" src="assets/c2.png" width="auto">
                </div>
            </div>
        </li>
    </ul>


    <h3>
        Implementazione
    </h3>
    <p>
        La curva implementata, come detto precedentemente, &egrave; una curva Spline che presenta incollature di
        classe
        \(C^{1}\) di curve di B&eacute;zier di grado 3. Le funzioni che si occupano di calcolare la curva di B&eacute;zier
        in
        funzione del parametro \(t\) sono:
    </p>
    <div style="margin: auto; width: 50%;">
        <code style="font-size: 120%;">
            public Vector3 Lerp(Vector3 a, Vector3 b, float t)<br>
            {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Vector3.Lerp(a, b, t);<br>
            }<br><br>


            public Vector3 QuadraticLerp(Vector3 a, Vector3 b, Vector3 c, float t)<br>
            {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 ab = Vector3.Lerp(a, b, t);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 bc = Vector3.Lerp(b, c, t);<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Vector3.Lerp(ab, bc, t);<br>
            }<br><br>


            public Vector3 CubicLerp(Vector3 a, Vector3 b, Vector3 c, Vector3 d, float t)<br>
            {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 ac = QuadraticLerp(a, b, c, t);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3 bd = QuadraticLerp(b, c, d, t);<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Vector3.Lerp(ac, bd, t);<br>
            }<br><br>
        </code>
    </div>
</div>

</body>
</html>
